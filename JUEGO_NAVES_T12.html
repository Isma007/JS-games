<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>JUEGO 2.0 | NAVES</title>
    <style>
        canvas{
            border:solid 5px #e30053;
            background-color:black;
        }
    </style>
</head>
<body>
    <script>

        game = {
            ctx: null,
            canvas: null,
            colorFill: "greenyellow",
            imagen: null,
            caratula: true,
            enemigos: null,
            teclaPulsada: null,
            tecla: [],
            colorBala: "blue",
            bala2: "blue",
            balas_array: new Array(),
            balasEnemigas_array: new Array(),
            enemigos_array: new Array(),
            disparo: false,
            puntos: 0,
            finJuego: false,
            boing: null,
            disparoJug: null,
            endGame: null,
            start: null,
        }
        let x = 10, y = 0;
        //CONSTANTES

        const KEY_ENTER = 13;
        const KEY_LEFT = 37;
        const KEY_UP = 38;
        const KEY_RIGHT = 39;
        const KEY_DOWN = 40;
        const KEY_BESPACIADORA = 32;
        //IMP El teclado ya tiene valores por defecto, no son inventados, están prefijados;

        //OBJETOS
        function bala(x,y,w) {//Eje X, Eje Y y Ancho(w);
            this.x = x;//Variable X local sea igual a la X otorgada en el valor de la f(x);
            this.y = y;
            this.w = w;
            this.dibujar = function () {
                //Dibujo de bala;
                game.ctx.save();//Permite guardar los elementos en su estado original;
                game.ctx.fillStyle = game.colorBala;
                game.ctx.fillRect(this.x, this.y, this.w, 10);//Sería coordenada X&Y y luego sería los mismo de ancho y largo, o NO;
                this.y = this.y-5;//Porcura el movimiento del láser hacia arriba, si se iguala, el láser es estático;
                game.ctx.restore();//Hace que se elimine las transformaciones y que se reestaure lo anterior;
            };
            //F(X) para que los enemigos disparen balas, muy parecido a las balas del player;
            this.disparar = function (x,y,w) {
                game.ctx.save();
                game.ctx.fillStyle = "blue";//No me deja llamar al objeto GAME, no se porqué;He tenido que meter el color manual;
                game.ctx.fillRect(this.x,this.y,this.w,20);//La explicación sería identica a la de arriba en las balas normales;
                this.y = this.y +6;//Es menos -5 para que la bala suba; en caso de ser positivo, la bala bajaría;
                game.ctx.restore();
            }
        }

        function jugador() {
            this.x = x;
            this.y = 600;//Localización del personaje dentro del lienzo;
            this.w = 30;//Añadimos W&H para las colisiones de las balas enemigas;
            this.h = 15;
            this.dibujar = function (x) {
                this.x = x;
                game.ctx.drawImage(game.imagen, this.x, this.y, this.w, this.h);//Los dos ultimos parametros son el ancho y largo que usamos para>>
                //<<las colisiones de las balas enemigas;
            }
        }

        function enemigos(x, y) {//Hemos cambiado esta parte de enmigo a enemigos ya que entraba en conflicto con las colisiones;
            this.x = x;
            this.y = y;
            this.w = 35;
            this.veces = 0;
            this.dx = 5;//velocidad del enemigo;
            this.ciclos = 0;
            this.num = 14;
            this.figura = true;//Imagen del enemigo cuando cambiamos;
            this.vive = true;
            this.dibujar = function () {
                //Retraso LatAm
                if (this.ciclos > 30) {//Cuando el ciclo sea menor a treinta; si cambias el movimiento será mucho más rapido;
                    //Saltos enemigos
                    if (this.veces > this.num) {//Y el numero de veces mayor que el numero, hacemos que la velocidad se incremente en -1;
                        this.dx *= -1
                        this.veces = 0;//Dice que regresa de nuevo la igualdad;
                        this.num = 28;
                        this.y += 20;
                        this.dx = (this.dx > 0) ? this.dx++ : this.dx--;//Igual-->if(this.dx>0){this.dx++}else{this.dx--};
                    } else {
                        this.x += this.dx;//Es decir que la X vaya aumentando de 5 en 5;
                    }
                    this.veces++;
                    this.ciclos = 0;
                    this.figura = !this.figura;//La interrogación produce que se genere el valor contrario, por lo tanto en la primera pasada se convierte>>
                    //<<en negativo, mientras que en la segunda vuelve a tornar positivo y así hasta el final;Produce que se alterne el true y el false>>
                    //<<haciendo posible que el this.figura dentro del if/else vaya cambiando, unas veces se cumpla y otras sea ELSE;

                } else {
                    this.ciclos++;//Este incremento se hace para que en algún momento, el if de arriba((this.ciclos < 30)) pueda darse>>
                    //<<y el conicional se active;

                }
                if (this.figura) {//Mediante este parámetro= this.figura = !this.figura; Producimos que el this.figura no sea siempre true y se alterna con false>>
                    //<<por lo tanto dentro del if/else, la condición no siempre se cumple posibilitando el drawImage del ELSE;
                    game.ctx.drawImage(game.enemigos, 0, 0, 40, 30, this.x, this.y, 35, 30);//Los dos ultimos son con referencia al frame de la imagen original;
                    //Los 4 primeros numeros son las coordenadas de elección de la imagen, es decir abajo es la misma imagen pero>>
                    //<<con las coordenadas cambiadas para enfocar hacia otro punto de la imagen completa;
                } else {
                    game.ctx.drawImage(game.enemigos, 50, 0, 35, 30, this.x, this.y, 35, 30);//Esta imagen es la misma que el drawImage de arriba salvo>>
                    //<< que las coordenadas, los 4 primeros numeros, son diferentes;

                }
            };
        }

        //FUNCIONES PARA LA CARÁTULA DEL JUEGO;
        const caratula = () => {
            let imagen = new Image();
            imagen.src = "cara.webp";//CHECK si está bien generada la ruta;
            imagen.onload = () => {
                game.ctx.drawImage(imagen, 0, 100);//En este caso son los puntos cardinales X&Y en los que se va a localizar la imagen;
            }
        }

        const seleccionar = (e) => {
            if (game.caratula) {
                inicio();
                game.start.play();
            }
        }

        const inicio = () => {
            game.ctx.clearRect(0, 0, game.canvas.width, game.canvas.height);
            game.caratula = false;
            game.jugador = new jugador(0);
            game.x = game.canvas.width / 5;//Guardamos la medida de la X que hemos abierto en la f(x) de jugador; Hasta donde yo>>
            //<<entiendo el game.x es una nueva condición que estamos añadiendo a nuestro jugador;
            game.jugador.dibujar(game.x);
            animar();
        }
        console.log(typeof game);
        console.log(game.balas_array.length);
        console.log(x);

        const animar = () => {
            if (game.finJuego == false) {
                requestAnimationFrame(animar);//Hace que se pueda leer en varios navegadores, el codigo es copiado;
                verificar();//<--Estos tres métodos son los motores que mueven el juego;
                pintar();//<--Estos tres métodos son los motores que mueven el juego;
                colisiones();//<--Estos tres métodos son los motores que mueven el juego;
            } else { }
            
        }
        const colisiones = () => {
            var enemigo;
            var bala;
            for (var i = 0; i < game.enemigos_array.length; i++) {//Gráficamente hablando, todos los enemigos están metidos en ese>>
                //<<array por eso, es la muestra total sobre la que vamos a trabajar;
                for (var j = 0; j < game.balas_array.length; j++) {
                    enemigo = game.enemigos_array[i];//Realizamos dos bucles y estos los igualamos a las var creadas;
                    bala = game.balas_array[j];
                    //Estos dos bucles for, recorren los dos arrays con los enemigos y con las balas y se guardan en las variables locales>>
                    //<<como son var=enemigo,var=bala;
                    if (enemigo != null && bala != null) {//Preguntamos si bala&enemigo son diferentes de valor sin determninar>>
                        //<<AKA Null;
                        if ((bala.x > enemigo.x) &&
                            (bala.x < enemigo.x + enemigo.w) &&//Con el ancho del enemigo hacemos que el no solo tenga la bala que ser mayor que>>
                            //<< el enemigo si no que además también 
                            (bala.y > enemigo.y) &&
                            (bala.y < enemigo.y + enemigo.w)) {//Se tienen que cumplir todas las condiciones tanto de ejeX como de eje Y>>
                            enemigo.vive = false;//Orden para que si se cumplen los requisitos, el boolean se elimine;
                            game.enemigos_array[i] = null;
                            game.balas_array[j] = null;//De tal modo que, a quien le toque la condición se convierta en valor indeterminado;
                            game.disparo = false;//En caso de mantenerlo en true no deja disparar de nuevo;

                            //SCORE dentro de las colisiones
                            game.puntos += 10;//Cada vez que hay una colisión se va incrementando los puntos, cuando se cumpla con la condición;
                            game.boing.play();
                        }
                    }
                }
            }
            //Colisiones de balas enemigas
            for (var j = 0; j < game.balasEnemigas_array.length; j++) {//Es una copia del bucle for de arriba;
                bala = game.balasEnemigas_array[j];//Guardamos todo lo que contenga el array balas enemigas;
                if (bala != null) {//Si es diferente de null significa que tiene información;
                    if ((bala.x > game.jugador.x) &&//Es decir bala eje x tiene que ser mayor a la posición del jugador en el eje X;
                        (bala.x < game.jugador.x + game.jugador.w) &&
                        (bala.y > game.jugador.y) &&
                        (bala.y < game.jugador.y + game.jugador.h)) {//A diferencia de las colisiones con los enemigos, aqui en la Y es suma con el alto;
                        gameOver();
                    }
                }
            }
        }
        const gameOver = () => {//f(x)para finalizar el juego con las colisiones, muy sencillo;
                //function simularF5() {//F(x) para que el juego se recargue; Se puede deshabilitar;
                    //location.reload()};
                    //simularF5();ESTO ES UN EJEMPLO PARA REINICIAR UNA VEZ MUERES;
            game.ctx.clearRect(0, 0, game.canvas.width, game.canvas.height);
            game.balas_array = [];
            game.enemigos_array = [];
            game.balasEnemigas_array = [];
            game.finJuego = true;
            game.start.pause();
            game.endGame.play();//Exactamente igual que en las balas del jugador;
            mensaje("Game Over", 100, 60);
            mensaje("Ganaste: " + game.puntos + " puntos", 220);
            if (game.puntos > 100 || game.puntos <= 200) {
                mensaje("Casi lo consigues", 340);//El tamaño ya está predeterminado en la const mensaje=()=>{};

            } else if (game.puntos > 200) {
                mensaje("¡Felicidades lo lograste!", 340);
            };

        }
        const mensaje = (cadena, y, size = 100) => {
            var medio = (game.canvas.width) / 2;
            game.ctx.save();
            game.ctx.fillStyle = "greenyellow";
            game.ctx.strokeStyle = "blue";
            game.ctx.textBaseline = "top";//Localización del texto una vez ganes o pierdas el juego;
            game.ctx.font = "bold 50px Courier";
            game.ctx.textAlign = "center";
            game.ctx.fillText(cadena, medio, y);//Donde se va a localizar el texto, es decir en el medio del canvas;
            game.ctx.restore();
        }

        const play_again = () => {
            function replay() {
                location.reload();
            }
            replay();
        }

        const verificar = () => {
            if (game.tecla[KEY_RIGHT]) game.x += 10;
            if (game.tecla[KEY_LEFT]) game.x -= 10;

            //LIMITES DEL CANVAS DEL CAÑÓN;
            if (game.x > game.canvas.width - 10) {
                game.x = game.canvas.width - 10;
            } //Lo que hacemos es que si el movimiento X del player>>
            //<< es superior al ancho del canvas, este reste 10 para volver a estar dentro del perímetro;
            if (game.x < 0) {
                game.x = -10;
            }

            //Disparo
            if (game.tecla[KEY_BESPACIADORA]) {
                //El if de abajo hace que sea mas dificl el juego ya que no permite realizar disparos de seguido;
                if (game.disparo == false) {
                    game.balas_array.push(new bala(game.jugador.x + 12, game.jugador.y - 3, 5))//Donde se encuentra el jugador se dispara la bala, es decir inicio X>>
                    //<<y el doce son las coordenadas exactas para que la bala salga justo del cañon, el nº 5 es el ancho bala;
                    //El push se usa para añadir elementos a un Array ya existente;
                    game.tecla[KEY_BESPACIADORA] = false;//Para dejar de disparar;
                    game.disparo = true;
                    game.disparoJug.play(); //Play()lenguaje ya predeterminado de JS para los objetos tipo sonido;
                }
            }
            //Ejecutamos el disparo del enemigo;
            if (Math.random() > 0.96) {
                dispararEnemigo();//Cuando llegue a ese numero o lo supere, llamará de manera random a dispararEnemigo(), que a su vez>>
                //<<escogera uno de los diez ultimos para que dispare debido al bucle for y al [Math.floor(Math.random)*10]; 
            }
        }
        const pintar = () => {
            game.ctx.clearRect(0, 0, game.canvas.width, game.canvas.height);
            //Jugador
            game.jugador.dibujar(game.x);//Llamamos al jugador y dentro al dibujo de la imagen, el game.x es el valor donde va a moverse;

            //Movimiento de balas
            for (var i = 0; i < game.balas_array.length; i++) {
                if (game.balas_array[i] != null) {//Utilizamos i ya que este va a ser nuestro valor numérico hasta el infinito;
                    game.balas_array[i].dibujar();//Dibujar la f(x) que estaban en el metodo jugador;
                    if (game.balas_array[i].y<0) {
                        game.balas_array[i] = null;
                        game.disparo = false;//Es decir en disparo() cambiamos el bolean a true para que no se cumpla la condición hasta>>
                        //<< que en este bucle for se convierta de nuevo en falso y arriba de nuevo pueda desbloquearse con la condición>>
                        //<< de tal modo que hasta que la bala no desaparezca no podamos disparar de nuevo;
                    }
                }
            }
        
            //Movimiento balas Enemigas;
            for (var i = 0; i < game.balasEnemigas_array.length; i++) {//En este caso es igual 
                if (game.balasEnemigas_array[i] != null) {//<--Esto significa que el enemigo existe ya que es diferente a null;
                    game.balasEnemigas_array[i].disparar();//El final ejecuta la f(x) de la bala de los enemigos para que dispare;
                    if (game.balasEnemigas_array[i].y > game.canvas.height) {
                        game.balasEnemigas_array[i] = null;
                    }
                }
            }
            //Enemigos
            for (var i = 0; i < game.enemigos_array.length; i++) {//Al igual que con las balas hacemos otro bucle con los enemigos>>
                //<< es decir llamamos al método dibujar para que se pueda ejecutar;
                if (game.enemigos_array[i] != null) {
                    game.enemigos_array[i].dibujar();//Con este if decimos que si el enemigo es diferente de null, osea que >>
                    //<<existen, queremos que los dibuje; En caso de ser igual a null, los elimina ya que estarán muertos;
                }
                
            }
            score();
        }
        const dispararEnemigo = () => {//Constante para elección de enemigos que sean los 10 primeros;
            var ultimos = new Array();
            for (var i = game.enemigos_array.length - 1; i > 0; i--) {//Bucle de retroceso;
                if (game.enemigos_array[i] != null) {
                    ultimos.push(i);//Añadimos el indice del bucle for para meter a todos los enemigos que se encuentran en la i>>
                    //<<es decir vamos a añadir los elementos que están guardados dentro de la i=enemigos_array-1; De atras hacia adelante;
                }
                if (ultimos.length == 10) {//Que se cierre el ultimo.length cuando llegue a 10;
                    break;
                }
            }
            var d = ultimos[Math.floor(Math.random() * 10)];
            game.balasEnemigas_array.push(new bala(game.enemigos_array[d].x + game.enemigos_array[d].w / 2, game.enemigos_array[d].y, 5));
            //La d son los enemigos que se encuentran arriba con el math.floor;
        }
        const score = () => {//Marcador de las vidas;
            game.ctx.save();
            game.ctx.fillStyle = "white";
            game.ctx.font = "bold 20px Courier";
            game.ctx.fillText("Score: " + game.puntos, 10, 20);//10 y 20 es el tamaño de la letra de los puntos;
            game.ctx.restore();
        }

        //BOTONES PARA MOVIMIENTO DE CAÑÓN/LISTENER
        document.addEventListener("keydown", function (e) {
            game.teclaPulsada = e.keyCode;//Otro metodo que no este obsoleto como marca el VS seria con event.key, se puede ver en>>
            //<<chatgpt para que te ayude a enfocarlo;
            game.tecla[e.keyCode] = true;
        });
        document.addEventListener("keyup", function (e) {
            game.tecla[e.keyCode] = false;
            //No copiamos el de arriba porque ya está declarado y no es necesario;
        });





        window.requestAnimationFrame = (function () {//Este codigo nos sirve para que se pueda leer en cualquier navegador;COPIADO;
            return window.requestAnimationFrame ||
                window.webkitRequestAnimationFrame ||
                window.mozRequestAnimationFrame ||
                function (callback) { window.setTomiout(callback, 17); }
        })();

        window.onload=function(){
            game.canvas = document.getElementById('canvas');
          let inicio = document.getElementById('inicio');
            let reinicio = document.getElementById('reinicio');
            if(game.canvas&&canvas.getContext){
                game.ctx=canvas.getContext('2d');
                if (game.ctx) {
                    //SONIDOS
                    game.disparoJug = document.getElementById('cuarto');
                    game.endGame = document.getElementById('tercero');
                    game.start = document.getElementById('segundo');

                    //Imagen Torreta
                    game.imagen = new Image();//Establecemos la imagen de la torreta que disparará el misil;
                    game.imagen.src = "Recursos/imagenes/torre.fw.png";
                    //animar();
                    //Enemigos;
                    game.enemigos = new Image();
                    game.enemigos.src = "invader.fw.png";
                    game.enemigos.onload = function () {
                        for (var i = 0; i < 5; i++) {//El i<10 quiere decir que van a salir 9 enemigos;
                            for (var j = 0; j < 10; j++) {//Anidamos un bucle for dentro de otro
                                game.enemigos_array.push(new enemigos(100 + 40 * j, 30 + 45 * i));//El push se usa para añadir elementos a un Array ya>>
                                //<<existente, además establecemos la aparición de los enemigos instanciando la clase; De hecho>>
                                //<<al multipliarlo por j o i lo que hacemos es que cada enemigo aparezca en una zona distinta;
                                //AHORA VAMOS A DIBUJAR() A LOS ENEMIGOS;

                            }
                        }
                    }
                    reinicio.addEventListener("click", play_again,true);//Reinicio del juego;
                    caratula();//Se pone en el canvas y es el inicio del juego;
                    game.canvas.addEventListener("click", seleccionar, false);//Es SELECCIONAR ya que dentro de esta, está el inicio>>
                    //<< y a su vez dentro del inicio tenemos el verificado en el que está los movimientos del teclado;
                    inicio.addEventListener("click", function () {
                        seleccionar();
                    }, false);

                }
            }
        }

    </script>
    <center>
        <canvas id="canvas" width="650" height="650">
        </canvas>
        <p></p>
        <button id="inicio">JUEGA YA!</button>
        <button id="reinicio">REINICIO</button>

        <audio id="primero">
            <source src="Recursos/sonidos/audio_1.mp3" />
        </audio>
        <audio id="segundo">
            <source src="Recursos/sonidos/audio_6.mp3" />
        </audio>
        <audio id="tercero">
            <source src="Recursos/sonidos/audio_5.mp3" />
        </audio>
        <audio id="cuarto">
            <source src="Recursos/sonidos/audio_4.mp3" />
        </audio>
    </center>
    

</body>
</html>